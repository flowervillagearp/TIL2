# xxd
주어진 파일이나 standard input으로 들어온 문자들에 대해서 hexdump(16진법)을 만들어줌. Endian에 관계 없이 파일에 존재하는 순

hexdump 형식으로 변환되었을때
```
00000000: 7468 6973 2069 7320 706c 6179 6772 6f75  this is playgrou
00000010: 6e64 2064 6174 6120 6669 6c65 0a0a 6927  nd data file..i'
00000020: 6420 6c69 6b65 2074 6f20 7465 7374 2068  d like to test h
00000030: 6578 6475 6d70 2061 6e64 2078 7864 2063  exdump and xxd c
00000040: 6f6d 6d61 6e64 0a0a 616e 6420 666f 6c6c  ommand..and foll
00000050: 6f77 696e 6720 7374 7269 6e67 2069 7320  owing string is 
00000060: 6e6f 7468 696e 6720 6c65 7473 2070 7265  nothing lets pre
00000070: 7465 6e64 2074 6869 7320 6973 2070 6173  tend this is pas
00000080: 7377 6f72 642e 2e2e 0a0a 736b 6a6c 736f  sword.....skjlso
00000090: 6972 626e 3034 396e 7361 326b 6a66 3063  irbn049nsa2kjf0c
000000a0: 7777 6669 6e72 6173 3234 6634 6a0a       wwfinras24f4j.
```
이런식의 모양으로 나옴.
* 왼쪽의 8자리 숫자: 파일의 offset 즉 바이트의 위치를 16진수로 나타낸 값임.위 hexdump값에서 00000000은 파일의 맨 앞이라는 뜻이고 00000010은 16바이트 뒤, 00000020은 32바이트 뒤라는 뜻이 됌.
* 가운데 4자리 숫자,문자 조합: 16진수로 표현된 실제 파일의 바이트 값예시로 ‘Helllo’라는 텍스트가 있다면 ASCII코드로 H(0x48), e(0x65), l(0x6c), o(0x6f)따라서 hexdump에서는 48 65 6c 6c 6f 이런 식으로 나옴.가독성을 위해 16바이트 단위로 끊어서 보여주고 2자리(1byte)씩 띄어서 보여줌(8바이트 단위 두 그룹으로 나눠 보여줄때도 있음)
* 오른쪽 문자: 가운데 16진수 값들을 ASCII문자로 변환한 내용임.사람이 읽을수 있는 문자는 그대로 나오고 제어문자, 표시 불가 문자는 .같은 기호로 대체됌가운데 16진수 값과 오른쪽 문자가 일치하는지 비교해서 단순 텍스트인지 실행 파일같은 바이너리인지 추측 가능

### 사용법
---
xxd [filename]

### option
1. a: 하나의 null line을 ‘*’로 대치
2. b: dump가 이진법으로 출력됌
3. c: 행당 출력되는 열의 갯수 설정
4. E: 오른쪽 열 문자열을 ASCII에서 EBCDIC으로 변경
5. g: 출력시 group으로 묶이는 byte의 갯수 설정
6. h: 사용 가능한 명령 요약하여 출력하고 종료
7. i: C언어에서 사용할수 있는 형식으로 출력
8. l: 설정된 길이 byte만큼만 출력
9. p: 주소나 ASCII없이 hexdump 내용만 출력
10. r: 16진수 데이터를 바이너리 데이터로 변환(원본 복원)
11. s: 설정된 위치에서부터 hexdump함
12. u: hex를 소문자 대신 대문자로 출력
13. v: xxd의 버전을 출력
14. 마지막에 파일 이름 쓰면 그 파일에 저장됌: xxd -r data.txt /temp/restored.bin // data.txt파일을 복원해서 /temp/restored.bin이라는 경로의 파일로 저장